{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction prepareSize(size) {\n  return {\n    url: size.url || size.src || '',\n    width: size.width,\n    height: size.height\n  };\n}\nfunction computeSize(sizes, minWidth) {\n  var minHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  // Do nothing if sizes contains only 1 item\n  if (sizes.length === 1) {\n    return sizes[0];\n  }\n\n  // Sorting in ascending order\n  var sorted = _toConsumableArray(sizes).sort(function (a, b) {\n    if (a.width < b.width) {\n      return -1;\n    }\n    if (a.width === b.width) {\n      return a.height > b.height ? 1 : -1;\n    }\n    return 1;\n  });\n  var matchesByWidth = sorted.filter(function (size) {\n    return size.width >= minWidth;\n  });\n  if (!matchesByWidth.length) {\n    // Biggest size\n    return sorted[sorted.length - 1];\n  }\n  if (!minHeight) {\n    return matchesByWidth[0];\n  }\n\n  // Searching by height\n  for (var i = 0; i < matchesByWidth.length; i++) {\n    var size = matchesByWidth[i];\n    if (size.height >= minHeight) {\n      return size;\n    }\n  }\n\n  // Sorting by height in ascending order\n  var sortedByHeight = matchesByWidth.sort(function (a, b) {\n    return a.height > b.height ? 1 : -1;\n  });\n  return sortedByHeight[sortedByHeight.length - 1];\n}\n\n/**\n * Searches for the smallest (?) suitable image from the sizes array.\n *\n * Or more precise, it returns:\n *   – if no suitable sizes (>= minWidth И >= minHeight): the biggest from all sizes;\n *   – there are any suitable (>= minWidth И >= minHeight): the smallest of the matching sizes;\n *\n * Returns null only in case of an empty/invalid array. The returned size can be smaller than minWidth or minHeight.\n *\n * The function doesn't take into about the retina screen (window.devicePixelRatio), so you have to calculate the right width/height from the outside to support it.\n *\n * WARN:\n * - does not reckon for letter-sizes (PhotosPhotoSizesType).\n * - does not know how to search for the \"nearest\" size, or the maximum image (there is a hack with the `Infinity` pass).\n *\n * @example\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 1) // => 1,1\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 2) // => 3,3\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 4) // => 3,3\n *\n * See more examples in tests\n */\nexport function getPhotoSize(sizes, minWidth) {\n  var minHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!Array.isArray(sizes) || !sizes.length) {\n    return null;\n  }\n  var size = computeSize(sizes, minWidth, minHeight);\n  return prepareSize(size);\n}","map":{"version":3,"names":["prepareSize","size","url","src","width","height","computeSize","sizes","minWidth","minHeight","arguments","length","undefined","sorted","_toConsumableArray","sort","a","b","matchesByWidth","filter","i","sortedByHeight","getPhotoSize","Array","isArray"],"sources":["E:\\lessonReactForm\\mini-app\\node_modules\\@vkontakte\\vkjs\\src\\getPhotoSize.ts"],"sourcesContent":["export interface PhotoSizeLike {\n  width: number;\n  height: number;\n  url?: string;\n  src?: string;\n}\n\nexport interface PhotoSize {\n  url: string;\n  width: number;\n  height: number;\n}\n\nfunction prepareSize(size: PhotoSizeLike): PhotoSize {\n  return {\n    url: size.url || size.src || '',\n    width: size.width,\n    height: size.height,\n  };\n}\n\nfunction computeSize(\n  sizes: PhotoSizeLike[],\n  minWidth: number,\n  minHeight: number | null = null,\n): PhotoSizeLike {\n  // Do nothing if sizes contains only 1 item\n  if (sizes.length === 1) {\n    return sizes[0];\n  }\n\n  // Sorting in ascending order\n  const sorted = [...sizes].sort((a, b) => {\n    if (a.width < b.width) {\n      return -1;\n    }\n\n    if (a.width === b.width) {\n      return a.height > b.height ? 1 : -1;\n    }\n\n    return 1;\n  });\n\n  const matchesByWidth = sorted.filter((size) => size.width >= minWidth);\n  if (!matchesByWidth.length) {\n    // Biggest size\n    return sorted[sorted.length - 1];\n  }\n\n  if (!minHeight) {\n    return matchesByWidth[0];\n  }\n\n  // Searching by height\n  for (let i = 0; i < matchesByWidth.length; i++) {\n    const size = matchesByWidth[i];\n    if (size.height >= minHeight) {\n      return size;\n    }\n  }\n\n  // Sorting by height in ascending order\n  const sortedByHeight = matchesByWidth.sort((a, b) => (a.height > b.height ? 1 : -1));\n\n  return sortedByHeight[sortedByHeight.length - 1];\n}\n\n/**\n * Searches for the smallest (?) suitable image from the sizes array.\n *\n * Or more precise, it returns:\n *   – if no suitable sizes (>= minWidth И >= minHeight): the biggest from all sizes;\n *   – there are any suitable (>= minWidth И >= minHeight): the smallest of the matching sizes;\n *\n * Returns null only in case of an empty/invalid array. The returned size can be smaller than minWidth or minHeight.\n *\n * The function doesn't take into about the retina screen (window.devicePixelRatio), so you have to calculate the right width/height from the outside to support it.\n *\n * WARN:\n * - does not reckon for letter-sizes (PhotosPhotoSizesType).\n * - does not know how to search for the \"nearest\" size, or the maximum image (there is a hack with the `Infinity` pass).\n *\n * @example\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 1) // => 1,1\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 2) // => 3,3\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 4) // => 3,3\n *\n * See more examples in tests\n */\nexport function getPhotoSize(\n  sizes: PhotoSizeLike[],\n  minWidth: number,\n  minHeight: number | null = null,\n): PhotoSize | null {\n  if (!Array.isArray(sizes) || !sizes.length) {\n    return null;\n  }\n\n  const size = computeSize(sizes, minWidth, minHeight);\n\n  return prepareSize(size);\n}\n"],"mappings":";AAaA,SAASA,WAAWA,CAACC,IAAmB,EAAa;EACnD,OAAO;IACLC,GAAG,EAAED,IAAI,CAACC,GAAG,IAAID,IAAI,CAACE,GAAG,IAAI,EAAE;IAC/BC,KAAK,EAAEH,IAAI,CAACG,KAAK;IACjBC,MAAM,EAAEJ,IAAI,CAACI;EACf,CAAC;AACH;AAEA,SAASC,WAAWA,CAClBC,KAAsB,EACtBC,QAAgB,EAED;EAAA,IADfC,SAAwB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EAE/B;EACA,IAAIH,KAAK,CAACI,MAAM,KAAK,CAAC,EAAE;IACtB,OAAOJ,KAAK,CAAC,CAAC,CAAC;EACjB;;EAEA;EACA,IAAMM,MAAM,GAAGC,kBAAA,CAAIP,KAAK,EAAEQ,IAAI,CAAC,UAACC,CAAC,EAAEC,CAAC,EAAK;IACvC,IAAID,CAAC,CAACZ,KAAK,GAAGa,CAAC,CAACb,KAAK,EAAE;MACrB,OAAO,CAAC,CAAC;IACX;IAEA,IAAIY,CAAC,CAACZ,KAAK,KAAKa,CAAC,CAACb,KAAK,EAAE;MACvB,OAAOY,CAAC,CAACX,MAAM,GAAGY,CAAC,CAACZ,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;IACrC;IAEA,OAAO,CAAC;EACV,CAAC,CAAC;EAEF,IAAMa,cAAc,GAAGL,MAAM,CAACM,MAAM,CAAC,UAAClB,IAAI;IAAA,OAAKA,IAAI,CAACG,KAAK,IAAII,QAAQ;EAAA,EAAC;EACtE,IAAI,CAACU,cAAc,CAACP,MAAM,EAAE;IAC1B;IACA,OAAOE,MAAM,CAACA,MAAM,CAACF,MAAM,GAAG,CAAC,CAAC;EAClC;EAEA,IAAI,CAACF,SAAS,EAAE;IACd,OAAOS,cAAc,CAAC,CAAC,CAAC;EAC1B;;EAEA;EACA,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,cAAc,CAACP,MAAM,EAAES,CAAC,EAAE,EAAE;IAC9C,IAAMnB,IAAI,GAAGiB,cAAc,CAACE,CAAC,CAAC;IAC9B,IAAInB,IAAI,CAACI,MAAM,IAAII,SAAS,EAAE;MAC5B,OAAOR,IAAI;IACb;EACF;;EAEA;EACA,IAAMoB,cAAc,GAAGH,cAAc,CAACH,IAAI,CAAC,UAACC,CAAC,EAAEC,CAAC;IAAA,OAAMD,CAAC,CAACX,MAAM,GAAGY,CAAC,CAACZ,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;EAAA,CAAC,CAAC;EAEpF,OAAOgB,cAAc,CAACA,cAAc,CAACV,MAAM,GAAG,CAAC,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASW,YAAYA,CAC1Bf,KAAsB,EACtBC,QAAgB,EAEE;EAAA,IADlBC,SAAwB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EAE/B,IAAI,CAACa,KAAK,CAACC,OAAO,CAACjB,KAAK,CAAC,IAAI,CAACA,KAAK,CAACI,MAAM,EAAE;IAC1C,OAAO,IAAI;EACb;EAEA,IAAMV,IAAI,GAAGK,WAAW,CAACC,KAAK,EAAEC,QAAQ,EAAEC,SAAS,CAAC;EAEpD,OAAOT,WAAW,CAACC,IAAI,CAAC;AAC1B"},"metadata":{},"sourceType":"module","externalDependencies":[]}