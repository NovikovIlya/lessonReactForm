{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"children\", \"getScrollToLeft\", \"getScrollToRight\", \"showArrows\", \"arrowSize\", \"scrollAnimationDuration\", \"getRef\", \"className\"];\nimport * as React from 'react';\nimport { useAdaptivityHasPointer } from '../../hooks/useAdaptivityHasPointer';\nimport { HorizontalScrollArrow } from './HorizontalScrollArrow';\nimport { easeInOutSine } from '../../lib/fx';\nimport { useEventListener } from '../../hooks/useEventListener';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { classNames } from '@vkontakte/vkjs';\n/**\n * timing method\n */\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n\n/**\n * Округляем el.scrollLeft\n * https://github.com/VKCOM/VKUI/pull/2445\n */\nvar roundUpElementScrollLeft = function roundUpElementScrollLeft(el) {\n  return Math.ceil(el.scrollLeft);\n};\n\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\nvar SCROLL_ONE_FRAME_TIME = 250;\nfunction doScroll(_ref) {\n  var scrollElement = _ref.scrollElement,\n    getScrollPosition = _ref.getScrollPosition,\n    animationQueue = _ref.animationQueue,\n    onScrollToRightBorder = _ref.onScrollToRightBorder,\n    onScrollEnd = _ref.onScrollEnd,\n    onScrollStart = _ref.onScrollStart,\n    initialScrollWidth = _ref.initialScrollWidth,\n    _ref$scrollAnimationD = _ref.scrollAnimationDuration,\n    scrollAnimationDuration = _ref$scrollAnimationD === void 0 ? SCROLL_ONE_FRAME_TIME : _ref$scrollAnimationD;\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n\n  /**\n   * максимальное значение сдвига влево\n   */\n  var maxLeft = initialScrollWidth - scrollElement.offsetWidth;\n  var startLeft = roundUpElementScrollLeft(scrollElement);\n  var endLeft = getScrollPosition(startLeft);\n  onScrollStart();\n  if (endLeft >= maxLeft) {\n    onScrollToRightBorder();\n    endLeft = maxLeft;\n  }\n  var startTime = now();\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n    var time = now();\n    var elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n    var value = easeInOutSine(elapsed);\n    var currentLeft = startLeft + (endLeft - startLeft) * value;\n    scrollElement.scrollLeft = Math.ceil(currentLeft);\n    if (roundUpElementScrollLeft(scrollElement) !== Math.max(0, endLeft) && elapsed !== 1) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n    onScrollEnd();\n    animationQueue.shift();\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/HorizontalScroll\n */\nexport var HorizontalScroll = function HorizontalScroll(_ref2) {\n  var children = _ref2.children,\n    getScrollToLeft = _ref2.getScrollToLeft,\n    getScrollToRight = _ref2.getScrollToRight,\n    _ref2$showArrows = _ref2.showArrows,\n    showArrows = _ref2$showArrows === void 0 ? true : _ref2$showArrows,\n    _ref2$arrowSize = _ref2.arrowSize,\n    arrowSize = _ref2$arrowSize === void 0 ? 'l' : _ref2$arrowSize,\n    _ref2$scrollAnimation = _ref2.scrollAnimationDuration,\n    scrollAnimationDuration = _ref2$scrollAnimation === void 0 ? SCROLL_ONE_FRAME_TIME : _ref2$scrollAnimation,\n    getRef = _ref2.getRef,\n    className = _ref2.className,\n    restProps = _objectWithoutProperties(_ref2, _excluded);\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    canScrollLeft = _React$useState2[0],\n    setCanScrollLeft = _React$useState2[1];\n  var _React$useState3 = React.useState(false),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    canScrollRight = _React$useState4[0],\n    setCanScrollRight = _React$useState4[1];\n  var isCustomScrollingRef = React.useRef(false);\n  var scrollerRef = useExternRef(getRef);\n  var animationQueue = React.useRef([]);\n  var hasPointer = useAdaptivityHasPointer();\n  var scrollTo = React.useCallback(function (getScrollPosition) {\n    var scrollElement = scrollerRef.current;\n    animationQueue.current.push(function () {\n      var _scrollElement$firstE;\n      return doScroll({\n        scrollElement: scrollElement,\n        getScrollPosition: getScrollPosition,\n        animationQueue: animationQueue.current,\n        onScrollToRightBorder: function onScrollToRightBorder() {\n          return setCanScrollRight(false);\n        },\n        onScrollEnd: function onScrollEnd() {\n          return isCustomScrollingRef.current = false;\n        },\n        onScrollStart: function onScrollStart() {\n          return isCustomScrollingRef.current = true;\n        },\n        initialScrollWidth: (scrollElement === null || scrollElement === void 0 ? void 0 : (_scrollElement$firstE = scrollElement.firstElementChild) === null || _scrollElement$firstE === void 0 ? void 0 : _scrollElement$firstE.scrollWidth) || 0,\n        scrollAnimationDuration: scrollAnimationDuration\n      });\n    });\n    if (animationQueue.current.length === 1) {\n      animationQueue.current[0]();\n    }\n  }, [scrollAnimationDuration, scrollerRef]);\n  var scrollToLeft = React.useCallback(function () {\n    var getScrollPosition = getScrollToLeft !== null && getScrollToLeft !== void 0 ? getScrollToLeft : function (i) {\n      return i - scrollerRef.current.offsetWidth;\n    };\n    scrollTo(getScrollPosition);\n  }, [getScrollToLeft, scrollTo, scrollerRef]);\n  var scrollToRight = React.useCallback(function () {\n    var getScrollPosition = getScrollToRight !== null && getScrollToRight !== void 0 ? getScrollToRight : function (i) {\n      return i + scrollerRef.current.offsetWidth;\n    };\n    scrollTo(getScrollPosition);\n  }, [getScrollToRight, scrollTo, scrollerRef]);\n  var onscroll = React.useCallback(function () {\n    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {\n      var scrollElement = scrollerRef.current;\n      setCanScrollLeft(scrollElement.scrollLeft > 0);\n      setCanScrollRight(roundUpElementScrollLeft(scrollElement) + scrollElement.offsetWidth < scrollElement.scrollWidth);\n    }\n  }, [hasPointer, scrollerRef, showArrows]);\n  var scrollEvent = useEventListener('scroll', onscroll);\n  React.useEffect(function () {\n    if (scrollerRef.current) {\n      scrollEvent.add(scrollerRef.current);\n    }\n  }, [scrollEvent, scrollerRef]);\n  React.useEffect(onscroll, [scrollerRef, children, onscroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({}, restProps, {\n    className: classNames(\"vkuiHorizontalScroll\", showArrows === 'always' && \"vkuiHorizontalScroll--withConstArrows\", className)\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiHorizontalScroll__in\",\n    ref: scrollerRef\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiHorizontalScroll__in-wrapper\"\n  }, children)), showArrows && (hasPointer || hasPointer === undefined) && canScrollLeft && /*#__PURE__*/React.createElement(HorizontalScrollArrow, {\n    size: arrowSize,\n    direction: \"left\",\n    className: \"vkuiHorizontalScroll__arrowLeft\",\n    onClick: scrollToLeft\n  }), showArrows && (hasPointer || hasPointer === undefined) && canScrollRight && /*#__PURE__*/React.createElement(HorizontalScrollArrow, {\n    size: arrowSize,\n    direction: \"right\",\n    className: \"vkuiHorizontalScroll__arrowRight\",\n    onClick: scrollToRight\n  }));\n};","map":{"version":3,"names":["React","useAdaptivityHasPointer","HorizontalScrollArrow","easeInOutSine","useEventListener","useExternRef","classNames","now","performance","Date","roundUpElementScrollLeft","el","Math","ceil","scrollLeft","SCROLL_ONE_FRAME_TIME","doScroll","_ref","scrollElement","getScrollPosition","animationQueue","onScrollToRightBorder","onScrollEnd","onScrollStart","initialScrollWidth","_ref$scrollAnimationD","scrollAnimationDuration","maxLeft","offsetWidth","startLeft","endLeft","startTime","scroll","time","elapsed","min","value","currentLeft","max","requestAnimationFrame","shift","length","HorizontalScroll","_ref2","children","getScrollToLeft","getScrollToRight","_ref2$showArrows","showArrows","_ref2$arrowSize","arrowSize","_ref2$scrollAnimation","getRef","className","restProps","_objectWithoutProperties","_excluded","_React$useState","useState","_React$useState2","_slicedToArray","canScrollLeft","setCanScrollLeft","_React$useState3","_React$useState4","canScrollRight","setCanScrollRight","isCustomScrollingRef","useRef","scrollerRef","hasPointer","scrollTo","useCallback","current","push","_scrollElement$firstE","firstElementChild","scrollWidth","scrollToLeft","i","scrollToRight","onscroll","scrollEvent","useEffect","add","createElement","_extends","ref","undefined","size","direction","onClick"],"sources":["E:\\lessonReactForm\\mini-app\\node_modules\\@vkontakte\\vkui\\src\\components\\HorizontalScroll\\HorizontalScroll.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useAdaptivityHasPointer } from '../../hooks/useAdaptivityHasPointer';\nimport { HorizontalScrollArrow } from './HorizontalScrollArrow';\nimport { easeInOutSine } from '../../lib/fx';\nimport { useEventListener } from '../../hooks/useEventListener';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { HasRef } from '../../types';\nimport { classNames } from '@vkontakte/vkjs';\nimport styles from './HorizontalScroll.module.css';\n\ninterface ScrollContext {\n  scrollElement: HTMLElement | null;\n  scrollAnimationDuration: number;\n  animationQueue: VoidFunction[];\n  getScrollPosition: (currentPosition: number) => number;\n  onScrollToRightBorder: VoidFunction;\n  onScrollEnd: VoidFunction;\n  onScrollStart: VoidFunction;\n  /**\n   * Начальная ширина прокрутки.\n   * В некоторых случаях может отличаться от текущей ширины прокрутки из-за transforms: translate\n   */\n  initialScrollWidth: number;\n}\n\nexport type ScrollPositionHandler = (currentPosition: number) => number;\n\nexport interface HorizontalScrollProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    HasRef<HTMLDivElement> {\n  /**\n   * Функция для расчета величины прокрутки при клике на левую стрелку.\n   */\n  getScrollToLeft?: ScrollPositionHandler;\n  /**\n   * Функция для расчета величины прокрутки при клике на правую стрелку.\n   */\n  getScrollToRight?: ScrollPositionHandler;\n  arrowSize?: 'm' | 'l';\n  showArrows?: boolean | 'always';\n  scrollAnimationDuration?: number;\n}\n\n/**\n * timing method\n */\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n\n/**\n * Округляем el.scrollLeft\n * https://github.com/VKCOM/VKUI/pull/2445\n */\nconst roundUpElementScrollLeft = (el: HTMLElement) => Math.ceil(el.scrollLeft);\n\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\nconst SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll({\n  scrollElement,\n  getScrollPosition,\n  animationQueue,\n  onScrollToRightBorder,\n  onScrollEnd,\n  onScrollStart,\n  initialScrollWidth,\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n}: ScrollContext) {\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n\n  /**\n   * максимальное значение сдвига влево\n   */\n  const maxLeft = initialScrollWidth - scrollElement.offsetWidth;\n\n  let startLeft = roundUpElementScrollLeft(scrollElement);\n  let endLeft = getScrollPosition(startLeft);\n\n  onScrollStart();\n\n  if (endLeft >= maxLeft) {\n    onScrollToRightBorder();\n    endLeft = maxLeft;\n  }\n\n  const startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    const time = now();\n    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n\n    const value = easeInOutSine(elapsed);\n\n    const currentLeft = startLeft + (endLeft - startLeft) * value;\n    scrollElement.scrollLeft = Math.ceil(currentLeft);\n\n    if (roundUpElementScrollLeft(scrollElement) !== Math.max(0, endLeft) && elapsed !== 1) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/HorizontalScroll\n */\nexport const HorizontalScroll = ({\n  children,\n  getScrollToLeft,\n  getScrollToRight,\n  showArrows = true,\n  arrowSize = 'l',\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n  getRef,\n  className,\n  ...restProps\n}: HorizontalScrollProps) => {\n  const [canScrollLeft, setCanScrollLeft] = React.useState(false);\n  const [canScrollRight, setCanScrollRight] = React.useState(false);\n\n  const isCustomScrollingRef = React.useRef(false);\n\n  const scrollerRef = useExternRef(getRef);\n\n  const animationQueue = React.useRef<VoidFunction[]>([]);\n\n  const hasPointer = useAdaptivityHasPointer();\n\n  const scrollTo = React.useCallback(\n    (getScrollPosition: ScrollPositionHandler) => {\n      const scrollElement = scrollerRef.current;\n\n      animationQueue.current.push(() =>\n        doScroll({\n          scrollElement,\n          getScrollPosition,\n          animationQueue: animationQueue.current,\n          onScrollToRightBorder: () => setCanScrollRight(false),\n          onScrollEnd: () => (isCustomScrollingRef.current = false),\n          onScrollStart: () => (isCustomScrollingRef.current = true),\n          initialScrollWidth: scrollElement?.firstElementChild?.scrollWidth || 0,\n          scrollAnimationDuration,\n        }),\n      );\n      if (animationQueue.current.length === 1) {\n        animationQueue.current[0]();\n      }\n    },\n    [scrollAnimationDuration, scrollerRef],\n  );\n\n  const scrollToLeft = React.useCallback(() => {\n    const getScrollPosition =\n      getScrollToLeft ?? ((i: number) => i - scrollerRef.current!.offsetWidth);\n    scrollTo(getScrollPosition);\n  }, [getScrollToLeft, scrollTo, scrollerRef]);\n\n  const scrollToRight = React.useCallback(() => {\n    const getScrollPosition =\n      getScrollToRight ?? ((i: number) => i + scrollerRef.current!.offsetWidth);\n    scrollTo(getScrollPosition);\n  }, [getScrollToRight, scrollTo, scrollerRef]);\n\n  const onscroll = React.useCallback(() => {\n    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {\n      const scrollElement = scrollerRef.current;\n\n      setCanScrollLeft(scrollElement.scrollLeft > 0);\n      setCanScrollRight(\n        roundUpElementScrollLeft(scrollElement) + scrollElement.offsetWidth <\n          scrollElement.scrollWidth,\n      );\n    }\n  }, [hasPointer, scrollerRef, showArrows]);\n\n  const scrollEvent = useEventListener('scroll', onscroll);\n  React.useEffect(() => {\n    if (scrollerRef.current) {\n      scrollEvent.add(scrollerRef.current);\n    }\n  }, [scrollEvent, scrollerRef]);\n  React.useEffect(onscroll, [scrollerRef, children, onscroll]);\n\n  return (\n    <div\n      {...restProps}\n      className={classNames(\n        styles['HorizontalScroll'],\n        showArrows === 'always' && styles['HorizontalScroll--withConstArrows'],\n        className,\n      )}\n    >\n      <div className={styles['HorizontalScroll__in']} ref={scrollerRef}>\n        <div className={styles['HorizontalScroll__in-wrapper']}>{children}</div>\n      </div>\n      {showArrows && (hasPointer || hasPointer === undefined) && canScrollLeft && (\n        <HorizontalScrollArrow\n          size={arrowSize}\n          direction=\"left\"\n          className={styles['HorizontalScroll__arrowLeft']}\n          onClick={scrollToLeft}\n        />\n      )}\n      {showArrows && (hasPointer || hasPointer === undefined) && canScrollRight && (\n        <HorizontalScrollArrow\n          size={arrowSize}\n          direction=\"right\"\n          className={styles['HorizontalScroll__arrowRight']}\n          onClick={scrollToRight}\n        />\n      )}\n    </div>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}